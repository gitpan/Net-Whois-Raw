#!/usr/bin/perl -w

use Net::Whois::Raw;
use Getopt::Std;
use strict;
use vars qw(
    $opt_s $opt_c $opt_S $opt_C $opt_d $opt_e $opt_t $opt_T $opt_a $opt_h $opt_F $opt_L $opt_A
);

getopts("scSCetdFLAT:a:h");

if ($opt_h) {
USAGE:
	print <<EOM;
Usage:	$0 [ -s | -S ] [ -c | -C ] [ -d ] [ -T <timeout> ] [ -a <src_ip> ] [ -t ] [ -F | -L | -A ] <domain> [ <server> ]

Switches:
-s	attempt to strip the copyright message or disclaimer.
-S	some exra rules for above
-c	attempts to return an empty answer for failed searches.
-C	some exra rules for above
-e	forces die if connection rate to server have been exceeded.
-T	set timeout for connection attempts
-t	enables caching.
-a	specify an ip address that should be used as source address
-d	enables debugging messages.
-F	returns results of the first query of recursive whois requests
-L	returns results of the last query of recursive whois requests (the default)
-A	returns results of the last query of recursive whois requests
EOM
	exit; 
}

$Net::Whois::Raw::OMIT_MSG = 0;
$Net::Whois::Raw::CHECK_FAIL = 0;

$Net::Whois::Raw::OMIT_MSG = 1 if $opt_s;
$Net::Whois::Raw::OMIT_MSG = 2 if $opt_S;
$Net::Whois::Raw::CHECK_FAIL = 1 if $opt_c;
$Net::Whois::Raw::CHECK_FAIL = 2 if $opt_C;
$Net::Whois::Raw::CHECK_EXCEED = 1 if $opt_e;
$Net::Whois::Raw::TIMEOUT = $opt_T;
$Net::Whois::Raw::CACHE_DIR = undef;
@Net::Whois::Raw::SRC_IPS = ($opt_a) if $opt_a;

$Net::Whois::Raw::DEBUG = 1 if $opt_d;

if ($opt_t) {
    if ($^O =~ /Win/) {
        $Net::Whois::Raw::CACHE_DIR = $ENV{'TEMP'} || "C:\\temp";
    } else {
        $Net::Whois::Raw::CACHE_DIR = $ENV{'TEMP'} || "/tmp";
        my @ent = getpwuid($>);
	# clear cache
        if (@ent) {
            foreach ("/tmp/$ent[0]", "$ent[7]/.pwhois") {
                mkdir $_, 0644;
                if (open(O, ">$_/__$$-$$.tmp")) {
                    close(O);
                    unlink "$_/__$$-$$.tmp";
                    $Net::Whois::Raw::CACHE_DIR = $_;
                    last;
                 }
            }
        }
    }
}

my $dom = $ARGV[0] || goto USAGE;

my $server = $ARGV[1];

eval {
	my $result;
	if ($opt_F || $opt_L || $opt_A) {
	    my $which_whois = $opt_F ? 'QRY_FIRST' : $opt_L ? 'QRY_LAST' : 'QRY_ALL';
	    $result = Net::Whois::Raw::get_whois($dom, $server, $which_whois);
	} else {
	    $result = Net::Whois::Raw::whois($dom, $server);
	}
	
	if ($result) {
		print $result;
	} else {
		print STDERR "Failed.\n";
	}
};
if ($@) {
	my $err = $@;
	$err =~ s/\s+at \S+ line \d+\.$//;
	print "\nWhois information could not be fetched:\n$err\n";
	exit -1;
}	

__END__

=head1 NAME

pwhois   - Perl written whois client

=head1 SYNOPSIS

	pwhois perl.com
	pwhois gnu.org
	pwhois -s police.co.il
	pwhois -c there.is.no.tld.called.foobar
	pwhois yahoo.com whois.networksolutions.com
	pwhois -T 10 funet.fi

etc etc.....

=head1 DESCRIPTION

Just invoke with a domain name, optionally with a whois server name.
Switches:
    B<-s> attempt to strip the copyright message or disclaimer.
    B<-S> some exra rules for above
    B<-c> attempts to return an empty answer for failed searches.
    B<-C> some exra rules for above
    B<-e> forces die if connection rate to server have been exceeded.
    B<-T> set timeout for connection attempts
    B<-t> enables caching.
    B<-a> specify an ip address that should be used as source address
    B<-d> enables debugging messages.
    B<-F> returns results of the first query of recursive whois requests
    B<-L> returns results of the last query of recursive whois requests (the default)
    B<-A> returns results of the last query of recursive whois requests
 
=head1 AUTHORS

Ariel Brosh B<schop@cpan.org>

Current Maintainer: Walery Studennikov B<despair@cpan.org>

=head1 SEE ALSO

L<Net::Whois::Raw>.
